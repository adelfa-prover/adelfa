Explanation of the Tactics
===========================

Tactics:
  - Search (id, atm-R, pi_R, base-R, top-R, bottom-L)
      `Search.'
  - Induction
      `Induction <int>.'
  - Case Analysis (base-L)
      `Case <id>.'
  - Intros (ctx-R, all-R, imp-R)
      `Intros.'
  - Exists (exists-R)
      `Exists <term>.'
  - Split (and-R, or-L)
      `Split <id>.'
  - Left (and-L, or-R)
      `Left <id>.'
  - Right (and-L, or-R)
      `Right <id>.'
  - Apply (all-L, ctx-L, imp-L)
      `Apply <id> to <ids>.'
  - Cut (cut)
      `Cut <formula>.'
  - Lemma Application
      `Apply <id> to <ids>.'

Note that formulas in the assumption set will be reduced using
exists-L and pi-L until a base type is reached in the judgment or
another connective is encountered.

LF Type Checking
----------------
Terms will be used by the LF type checker.

Type checking will decompose the term structure based on the "type"
until a base type is reached, then we will look up the type of the
head and check each argument is of the appropriate type.

Looking up types uses the symbol/name and uses the signature if a
constant or the context if a variable.

It is possible to be doing LF type checking and find variables which
are *not* in the context; this happens, for example, if we are
checking the derivability of an atomic formula which contains
eigenvariables. If one of these is discovered it is not derivable.

Type checking will need to be able to check the equivalence of types
under substitutions (and thus also needs to do normalization).


Search
------
Attempts to complete a derivation using easy-to-apply-automatically
rules like id, atm-R, pi-R, base-R, top-R, and bottom-L.

If the goal formula is top, then am application of top-R ends the
derivation.

If bottom is in the assumption set then application of bottom-L will
complete the derivation

If the goal formula F also appears in the assumptions formula set
(equiv. up to renaming of nabla or quantified variables) then a
derived id rule would apply (break down into goal formulas, then apply
id at the leaves).

If the goal is atomic, could attempt to derive judgment in LF. This
requires that the context, Term representing the LF object, and the
Term representing the LF type are all convertible to appropriate
objects for the type checking. This could be achieved by using the
same representation throughout.
Q: Will LF type checking use the same term representation?
     I think it should so that we don't have to deal with converting
     back and forth. It is just different "views" of the terms, as
     terms in the logic or as LF objects/types.

Otherwise we want to decompose the goal using pi-R and base-R until
the subgoals are all satisfiable by something in the assumption
set. This would be done by looking at the structure of the Term
representing the LF type and trying pi-R or base-R depending on if it
is a Pi or an Application.

Induction
---------
Induction does not consider terms; it is applied to formulas.

Induction will modify the current subgoal by adding the the assumption
set a formula that is the original goal formula with the identified
atomic subformula annotated with the * (lt) annotation and replace the
goal formula with the original goal formula with the identified atomic
subformula annotated with the @ (eq) annotation.

For nested inductions we can use ** and @@ to distinguish between the
two heights.

Case Analysis
-------------
Case analysis will look at the context, the Term representing an LF
object, and the Term representing the LF type. Since it will apply
only to atomic formulas with an application for the Term representing
the LF type it will not need to decompose the structure at all.

It will consider each object-level constant in the signature and check
if there are any instances whose type can be unified with the Term
from the formula. Since type-level variables are not part of LF we can
use the type-level constant appearing at the head of the Term to
reduce the object-level constants we consider. It will also consider
each variable in the context and check if any of these have instances
whose type can be unified.

For each constant or variable that is found to have a unifier we
create a subgoal by applying the unifier to each component of the
sequent and then replacing the assumption formula being analyzed with
the new assumptions (apply unifier, then use Base-L).

It will also consider the possibility that the match was from some
as-yet-unspecified part of the context. It will lookup the schema
annotation for the context variable (if the context has one) and then
lookup the block structures of that schema definition. For each of the
block structures a "generic instance" is formed (using variables for
the schematic variables of the block definition) and we construct
cases by placing this new block in each possible position in the
context structure. This means the type of the context variable in the
context variable context is updated. ***We will need to raise all the
eigenvariables over these new nominal constants to ensure dependencies
are ok***. Then we look for cases as above.
Q: Do we need to come up with weak types for the variables introduced
   by a generic instance?
   How/when should be determine these?

Unification
-----------
unification is going to be pattern unification.

unification will use the simply-typed or weak typing view of Terms. It
will require application of substitutions to the terms and
normalization for checking equivalence.

The weak types for known variables will be used to determine weak
types for any variables introduced during unification. If unification
is unable to finish b/c non pattern equations remain then the
application of case analysis leading to this unification problem will
fail to apply b/c soundness requires that we can either come up with
unifiers or determine that no unifier exists.

We want to re-use the unification procedure from Abella as much as
possible, so making a similar Term structure would be helpful in this.

Intros
------
Use introduction rules (imp-R, all-R, ctx-R) to decompose the goal
formula.

Intros will use rules like all-R and imp-R to decompose the goal
formula. It does not work with the terms really, except that an all-R
could potentially trigger a renaming of a variable in the rest of the
body depending on how those are implemented.
Q: What happens if a variable name is reused in a formula?
   How do we represent that, and do we perform renaming?

exists
--------
Given a Term, replace the quantified variable with that term
(exists-R).

This requires checking that the given Term satisfies the weak typing
constraints to be an instantiation for that quantifier. It will
perform weak type checking on the term based on the weak type
annotating the quantifier. Since weak types can contain type variables
this may cause updates to the weak typing constraints for the
sequent. After updating the constraints if necessary, the term is then
substituted for the variable in the formula.

Weak Type Checking
------------------
This is essentially simple type checking.

It will need to access the weak types for variables and constants. We
will need to have weak types annotating eigenvariables so that the
types of variables can be looked up.

And-R
-----
Creates two subgoals, one with the left subformula as a goal and one
with the right subformula as a goal.

And-L
-----
Replaces the conjunctive assumption with either the left or right
subformula.

Or-R
-----
Replace the disjunctive goal with either the left or right
subformula.

Or-L
----
Creates two subgoals, one with the left subformula and one witht he
right subformula in the assumption set.

apply tactic (imp-L, all-L, ctx-L)
----------------------------------
Apply an assumption formula to some number of instantiations for
universal quantifiers and appropriate derivations for imp-L rule
applications.

Given
  apply Hyp to H1 H2 ... Hn with x1=y1 ... xm=ym and z1=ctx1 ... zj=ctxj
applies imp-L, all-L, or ctx-L to a fomrula Hyp using H1,...,Hn for
identifying appropriate hypotheses to satisfy the premise of imp-L,
y1,...,ym to identify what instantiations for make for universal
quantifiers in all-L, and ctx1,...,ctxj to identify what
instantiations to make for context quantifiers. Will return the
subgoal with the result of this instantiation of Hyp in the
assumption set. 

It would be nice to at some later time allow for inferrring the
y1,...,ym and ctx1,...,ctxj from the H1,...,Hn but I will not be
working on this immediately.

Cut
---
given a formula, adds new subgoal with that formula then sets as the
next subgoal the current subgoal but extends the assumption formulas
with the cut formula.

Lemma Application
-----------------
Essentially like cutting in the lemma formula, using the already
constructed proof to derive it, and then using apply on the formula
introduced to the assumption set by the cut.

