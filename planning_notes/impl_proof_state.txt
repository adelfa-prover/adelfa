The proof state is a conceptual view of all the available information
available during a derivation. At a high level, the interactions with
the user are just manipulations of some part of the proof state.

Proof State
===========
The proof state will need to include the LF signature for well
formedness and type checking, the available schema definitions
similarly, the theorems already proven which can be used as lemmas in
the current derivation, the current sequent being worked on, and a
stack representing the remaining goals we need to show to complete the
current theorem.

  Components:
    - LF signature
    - list of context schema definitions
        picked a list for this because I would expect only a few
        schema definitions would be used for any given development. We
        also would expect to lookup a schemas definition somewhat
        rarely as they are used in checking supplied context
        expressions in ctx-L and for generating context cases in case
        analysis. In both rules, at most one lookup of a schema
        definition is performed.
    - list of available lemmas
      [(name, formula+constraint eqns) pair list]
        A list is chosen because we only use this list to lookup a
        formula for lemma application. Only one lookup will be
        performed per use of this tactic, and there will likely be
        relatively few lemmas in a particular development.
    - Current Sequent
    - Stack of additional Sequents
        A stack was chosen for tracking the other sequents/subgoals as
        we will want to make sure to complete the most recently
        created branches before returning back to an outer set of
        cases.

  Operations:
    - load a signature
    - define a context schema
    - state theorem (as formula)
    - apply tactics
