Specification "sn-alt.lf".

Schema c :=
 {T}(x:tm,y:of x T).
 
%% sanity check:
%% if a term is strongly normalizing for some N, then is strongly normalizing for any larger N
Theorem sn_n__sn_sn :
ctx G:c, forall N M D, {G |- D : sn N M} => exists D', {G |- D' : sn (s N) M}.
induction on 1. intros. case H1. apply IH to H4.
assert {G |- s N1 : nat}. search.
exists sn_tm (s N1) M  ([x][y]D' y x). search.

%% The following two theorems let us omit some assumptions about
%% typing which can be infered from other assumption derivations
Theorem step__tm :
ctx G:c, forall M N D, {G |- D : step M N} => {G |- M : tm} /\ {G |- N : tm}.
induction on 1. intros. case H1.
  %case 1: step_lam
    apply IH to H5. case H6. split. search. search.
  %case 2: step_beta
    split. search. inst H3 with n = M1. search.
  %case 3: step_app2
    apply IH to H5. case H6. split. search. search.
  %case 4: step_app1
    apply IH to H5. case H6. split. search. search.
    
Theorem sn__nat_tm :
ctx G:c, forall N M D, {G |- D : sn N M} => {G |- N : nat} /\ {G |- M : tm}.
intros. case H1. split. search. search.

%Formulas for sn:
%(ctx G:c, forall N M,
%    {G |- M : tm} =>
%    (forall M' D, {G |- D : step M M'} => exists D', {G |- D' : sn N M'}) =>
%        exists D, {G |- D : sn (s N) M})
% and
%(ctx G:c, forall N M D,
%    {G |- D : sn (s N) M} =>
%        forall M' D, ({G |- D : step M M'} => exists D', {G |- D' : sn N M'}))
%% The later of these formulas can be proved directly in the logic using instantiation.
Theorem sn_step__sn : ctx G:c, forall N M D,
    {G |- D : sn (s N) M} =>
        forall M' D, ({G |- D : step M M'} => exists D', {G |- D' : sn N M'}).
intros. case H1. apply step__tm to H2. case H6.
inst H5 with n = M'. inst H9 with n1 = D1.
exists (P M' D1). search.

%% reduction steps preserve typing (subject reduction)
Theorem of_step : ctx G:c, forall M M' T D1 D2,
{G |- D1 : of M T} => {G |- D2 : step M M'} => exists D3, {G |- D3 : of M' T}.
induction on 2. intros. case H2.
  %case 1: step_lam
    case H1. apply IH to H10 H6. prune H11.
    exists (of_lam ([x]R' x) T1 T2 ([x][y]D1 y x)). search.
  %case 2: step_beta
    case H1. case H10.
    inst H15 with n2 = M1. inst H16 with n3 = D5.
    exists (D6 M1 D5). search.
  %case 3: step_app2
    case H1. apply IH to H12 H6.
    exists (of_app M1 N' T U a1 D3). search.
  %case 4: step_app1
    case H1. apply IH to H11 H6.
    exists (of_app M'1 N T U D3 a2). search.

%% sn is preserved by reduction steps (essentially just the meaning of sn)
Theorem sn_step : ctx G:c, forall N M M' D1 D2,
{G |- D1 : sn (s N) M} => {G |- D2 : step M M'} => exists D3, {G |- D3 : sn N M'}.
intros. case H1. apply step__tm to H2. case H6. inst H5 with n = M'. inst H9 with n1 = D2.
exists (P M' D2). search.

%%CR2
Theorem reduce_step :
ctx G:c, forall M M' T D1 D2,
    {G |- D1 : reduce M T} => {G |- D2 : step M M'} => exists D3, {G |- D3 : reduce M' T}.
induction on 1. intros. apply step__tm to H2. case H3. case H1.
  %case 1: reduce_arr
    %%%to obtain the typing judgement {G |- D : of N (arr A B)}
      apply of_step to H9 H2. prune H11.
    %%%to obtain the reducibility judgement {G |- [x][y] D x y : {x:tm}{y:of x A}reduce (app M' x) B}
      assert {G, n:tm, n1:reduce n A |- step_app1 M n M' D2 : step (app M n) (app M' n)}.
        weaken H7 with tm. weaken H4 with tm. weaken H13 with (reduce n3 A).
        weaken H5 with tm. weaken H15 with (reduce n5 A).
        weaken H2 with tm. weaken H17 with (reduce n7 A).
        search.
      apply IH to H10 H12.
      exists (reduce_arr M' A B D3 ([x][y]D1 y x)). search.
  %case 2: reduce_top
    apply of_step to H8 H2. apply sn_n__sn_sn to H9. apply sn_step to H11 H2.
    exists (reduce_top N M' D3 D1). search.

%%% sn (app M x) => sn M
Theorem sn_app_c :
(ctx G:c, forall N M,
    {G |- M : tm} =>
    (forall M' D, {G |- D : step M M'} => exists D', {G |- D' : sn N M'}) =>
        exists D, {G |- D : sn (s N) M}) => 
ctx G:c, forall N M x D,
{G |- N : nat} => {G |- D : sn N (app M x)} => exists D, {G |- D : sn N M}.
induction on 2. intros. case H3(keep). case H2(keep).
%%%% using the lemma sn_step__sn to move from sn derivation to formula
apply sn_step__sn to H3.
%%%% show the key property of being strongly normalizing: anything M steps to is strongly normalizing
assert (forall M' D, {G |- D : step M M'} => exists D', {G |- D' : sn N1 M'}).
  intros. prune H9. apply step__tm to H9. case H10. prune H12.
  assert {G |- step_app1 M x M' D: step (app M x) (app M' x)}.
    case H5. search.
  apply H8 to H13. prune H14.
  apply IH to H1. apply H15 to H7 H14. prune H16.
  exists D1. search.
%%%% use the assumption formula H1 to move from the formula to an sn derivation and conclude
case H5. apply H1 to H10 H9. prune H12.
exists D. search.

%% Anything cc steps to is reducible.
Theorem c_step_reduce : ctx Gamma:c, forall T, {T : ty} =>
(forall M3 D3, {Gamma |- D3 : step cc M3} => exists D4, {Gamma |- D4 : reduce M3 T}).

intros. case H2.

%% CR1 & CR3
Theorem cr1_cr3 : 
(ctx G:c, forall N M,
    {G |- M : tm} =>
    (forall M' D, {G |- D : step M M'} => exists D', {G |- D' : sn N M'}) =>
        exists D, {G |- D : sn (s N) M}) =>
(
ctx Gamma:c, forall T, {T : ty} =>
    (forall M1 D1, {Gamma |- D1 : reduce M1 T} => exists D2 N, {Gamma |- D2 : sn N M1}) /\

    (forall M2, (forall T0 R0, (exists D1, {Gamma |- D1 : eq_tm M2 (lam T0 R0)}) => false) =>
        (forall M3 D3, {Gamma |- D3 : step M2 M3} => exists D4, {Gamma |- D4 : reduce M3 T}) =>
	exists D5, {Gamma |- D5 : reduce M2 T})
).

induction on 2. intros. split.

%%%% CR1
case H2.
%% CR1 arr case
  intros. case H5.

  % establish that we can use CR3 on cc.
  inst H10 with n = cc.
  apply c_step_reduce to H3 with (Gamma = Gamma).

  assert (forall T0 R0, (exists D1, {Gamma |- D1 : eq_tm cc (lam T0 R0)}) => false).
    intros. case H13.

  % prepare CR3 for the argument type.
  apply IH to H1. apply H14 to H3 with (G3 = Gamma). case H15.

  % apply CR3
  apply H17 to H13 H12 with M2 = cc.
  prune H18.

  inst H11 with n1 = D5.

  % prepare CR1 for the result type.
  apply H14 to H4 with (G3 = Gamma).
  case H20.

  % apply CR1
  apply H21 to H19 with M1 = (app M1 cc), D1 = (P cc D5).

  % apply sn_app_c
  apply sn__nat_tm to H23.
  case H24.
  apply sn_app_c to H1.
  apply H27 to H25 H23.

  exists (D1 n1 n). exists (N n n1). search.
  
%% CR1 top case
  intros. case H3.

  exists S. exists N. search.

%%%% CR3
case H2.
%% CR3 arr case
  intros.

  % to be continued...
  abort.