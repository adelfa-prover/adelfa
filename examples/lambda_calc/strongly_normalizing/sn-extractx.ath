Specification "sn-alt.lf".

Schema c :=
 {T}(x:tm,y:of x T);
 {T}(x:tm,y:of x T,z:reduce x T).
 
%% sanity check:
%% if a term is strongly normalizing for some N, then is strongly normalizing for any larger N
Theorem sn_n__sn_sn :
ctx G:c, forall N M D, {G |- D : sn N M} => exists D', {G |- D' : sn (s N) M}.
induction on 1. intros. case H1. apply IH to H4.
assert {G |- s N1 : nat}. search.
exists sn_tm (s N1) M  ([x][y]D' y x). search.

%% The following two theorems let us omit some assumptions about
%% typing which can be infered from other assumption derivations
Theorem step__tm :
ctx G:c, forall M N D, {G |- D : step M N} => {G |- M : tm} /\ {G |- N : tm}.
induction on 1. intros. case H1.
  %case 1: step_lam
    apply IH to H5. case H6. split. search. search.
  %case 2: step_beta
    split. search. inst H3 with n = M1. search.
  %case 3: step_app2
    apply IH to H5. case H6. split. search. search.
  %case 4: step_app1
    apply IH to H5. case H6. split. search. search.
    
Theorem sn__nat_tm :
ctx G:c, forall N M D, {G |- D : sn N M} => {G |- N : nat} /\ {G |- M : tm}.
intros. case H1. split. search. search.

%Formulas for sn:
%(ctx G:c, forall N M,
%    {G |- M : tm} =>
%    (forall M' D, {G |- D : step M M'} => exists D', {G |- D' : sn N M'}) =>
%        exists D, {G |- D : sn (s N) M})
% and
%(ctx G:c, forall N M D,
%    {G |- D : sn (s N) M} =>
%        forall M' D, ({G |- D : step M M'} => exists D', {G |- D' : sn N M'}))
%% The later of these formulas can be proved directly in the logic using instantiation.
Theorem sn_step__sn : ctx G:c, forall N M D,
    {G |- D : sn (s N) M} =>
        forall M' D, ({G |- D : step M M'} => exists D', {G |- D' : sn N M'}).
intros. case H1. apply step__tm to H2. case H6.
inst H5 with n = M'. inst H9 with n1 = D1.
exists (P M' D1). search.

%% reduction steps preserve typing (subject reduction)
Theorem of_step : ctx G:c, forall M M' T D1 D2,
{G |- D1 : of M T} => {G |- D2 : step M M'} => exists D3, {G |- D3 : of M' T}.
induction on 2. intros. case H2.
  %case 1: step_lam
    case H1. apply IH to H10 H6. prune H11.
    exists (of_lam ([x]R' x) T1 T2 ([x][y]D1 y x)). search.
  %case 2: step_beta
    case H1. case H10.
    inst H15 with n2 = M1. inst H16 with n3 = D5.
    exists (D6 M1 D5). search.
  %case 3: step_app2
    case H1. apply IH to H12 H6.
    exists (of_app M1 N' T U a1 D3). search.
  %case 4: step_app1
    case H1. apply IH to H11 H6.
    exists (of_app M'1 N T U D3 a2). search.

%% sn is preserved by reduction steps (essentially just the meaning of sn)
Theorem sn_step : ctx G:c, forall N M M' D1 D2,
{G |- D1 : sn (s N) M} => {G |- D2 : step M M'} => exists D3, {G |- D3 : sn N M'}.
intros. case H1. apply step__tm to H2. case H6. inst H5 with n = M'. inst H9 with n1 = D2.
exists (P M' D2). search.

%%CR2
Theorem reduce_step :
ctx G:c, forall M M' T D1 D2,
    {G |- D1 : reduce M T} => {G |- D2 : step M M'} => exists D3, {G |- D3 : reduce M' T}.
induction on 1. intros. apply step__tm to H2. case H3. case H1.
  %case 1: reduce_arr
    %%%to obtain the typing judgement {G |- D : of N (arr A B)}
      apply of_step to H9 H2. prune H11.
    %%%to obtain the reducibility judgement {G |- [x][y] D x y : {x:tm}{y:of x A}reduce (app M' x) B}
      assert {G, n:tm, n1:reduce n A |- step_app1 M n M' D2 : step (app M n) (app M' n)}.
        weaken H7 with tm. weaken H4 with tm. weaken H13 with (reduce n3 A).
        weaken H5 with tm. weaken H15 with (reduce n5 A).
        weaken H2 with tm. weaken H17 with (reduce n7 A).
        search.
      apply IH to H10 H12.
      exists (reduce_arr M' A B D3 ([x][y]D1 y x)). search.
  %case 2: reduce_top
    apply of_step to H8 H2. apply sn_n__sn_sn to H9. apply sn_step to H11 H2.
    exists (reduce_top N M' D3 D1). search.
  %case 3: in context
    case H2.

%%% sn (app M x) => sn M
Theorem sn_app_c :
(ctx G:c, forall N M,
    {G |- M : tm} =>
    (forall M' D, {G |- D : step M M'} => exists D', {G |- D' : sn N M'}) =>
        exists D, {G |- D : sn (s N) M}) => 
ctx G:c, forall N M x D,
{G |- N : nat} => {G |- D : sn N (app M x)} => exists D, {G |- D : sn N M}.
induction on 2. intros. case H3(keep). case H2(keep).
%%%% using the lemma sn_step__sn to move from sn derivation to formula
apply sn_step__sn to H3.
%%%% show the key property of being strongly normalizing: anything M steps to is strongly normalizing
assert (forall M' D, {G |- D : step M M'} => exists D', {G |- D' : sn N1 M'}).
  intros. prune H9. apply step__tm to H9. case H10. prune H12.
  assert {G |- step_app1 M x M' D: step (app M x) (app M' x)}.
    case H5. search.
  apply H8 to H13. prune H14.
  apply IH to H1. apply H15 to H7 H14. prune H16.
  exists D1. search.
%%%% use the assumption formula H1 to move from the formula to an sn derivation and conclude
case H5. apply H1 to H10 H9. prune H12.
exists D. search.

%% Anything cc steps to is reducible.
Theorem c_step_reduce : ctx Gamma:c, forall T, {T : ty} =>
(forall M3 D3, {Gamma |- D3 : step cc M3} => exists D4, {Gamma |- D4 : reduce M3 T}).

intros. case H2.

Theorem weaken_ctx : ctx Gamma:c, forall T, {T : ty} =>
  {Gamma |- T : ty}.

  induction on 1. intros. case H1.

  % arr case
    apply IH to H2 with (Gamma = Gamma).
    apply IH to H3 with (Gamma = Gamma).
    search.
  % top case
    % MINORBUG: why doesn't this search succeed? A constant should be able to be
    % typed in any context.
    search.
    skip.

Theorem reduce_of : ctx Gamma:c, forall M T D, {Gamma |- D : reduce M T} =>
  exists D2, {Gamma |- D2 : of M T}.

  intros. case H1.
  % MINOR BUG: why does Adelfa list Gamma as Gamma{n1, n}? n1 and n aren't in Gamma.
  exists D1. search.
  exists D1. search.
  % NOTE: fails due to the issue with using assumptions in the context.
  % QUESTION: also, why is T (T n n1 n2)? Shouldn't it have been well formed without
  % encountering those nominals?
  exists n1. search.

%% CR1 & CR3
Theorem cr1_cr3 : 
(ctx G:c, forall N M,
    {G |- M : tm} =>
    (forall M' D, {G |- D : step M M'} => exists D', {G |- D' : sn N M'}) =>
        exists D, {G |- D : sn (s N) M}) =>
(
ctx Gamma:c, forall T, {T : ty} =>
    (forall M1 D1, {Gamma |- D1 : reduce M1 T} => exists D2 N, {Gamma |- D2 : sn N M1}) /\

    (forall M2, {Gamma |- M2 : tm} =>
      (forall T0 R0, (exists D1, {Gamma |- D1 : eq_tm M2 (lam T0 R0)}) => false) =>
      (forall M3 D3, {Gamma |- D3 : step M2 M3} => exists D4, {Gamma |- D4 : reduce M3 T}) =>
      exists D5, {Gamma |- D5 : reduce M2 T})
).

induction on 2. intros. split.

%%%% CR1
case H2.
%% CR1 arr case
  intros. case H5.

  % establish that we can use CR3 on cc.
  inst H10 with n = cc.
  apply c_step_reduce to H3 with (Gamma = Gamma).

  assert (forall T0 R0, (exists D1, {Gamma |- D1 : eq_tm cc (lam T0 R0)}) => false).
    intros. case H13.

  % prepare CR3 for the argument type.
  apply IH to H1. apply H14 to H3 with (G3 = Gamma). case H15.

  % apply CR3
  assert {Gamma |- cc : tm}. search.
  apply H17 to H18 H13 H12 with M2 = cc.
  prune H19.

  inst H11 with n1 = D5.

  % prepare CR1 for the result type.
  apply H14 to H4 with (G3 = Gamma).
  case H21.

  % apply CR1
  apply H22 to H20 with M1 = (app M1 cc), D1 = (P cc D5).

  % apply sn_app_c
  apply sn__nat_tm to H24.
  case H25.
  apply sn_app_c to H1.
  apply H28 to H26 H24.

  exists (D1 n1 n). exists (N n n1). search.

%% CR1 variable case w/ arr
  assert (forall M', forall D, {Gamma |- D : step n M'} => exists D',
            {Gamma |- D' : sn z M'}).
    intros.
    case H6.

  % MINORBUG: how am I supposed to get {Gamma |- n : tm} if that is in Gamma?
  assert {Gamma |- n : tm}. search. skip.

  apply H1 to H7 H6 with N = z, M = n.
  % NOTE: matching formulas like happens ^ can mean naming hypotheses to exactly
  % match names.

  exists (D n2 n1 n). exists (s z). search.
  
%% CR1 top case
  intros. case H3.

  exists S. exists N. search.

%% CR1 var top case.
  assert (forall M', forall D, {Gamma |- D : step n M'} => exists D',
            {Gamma |- D' : sn z M'}).
    intros.
    case H4.

  assert {Gamma |- n : tm}. search. skip.

  apply H1 to H5 H4 with N = z, M = n.

  exists (D n2 n1 n). exists (s z). search.

%%%% CR3
case H2.
%% CR3 arr case
  intros.

%% Some things cascade into this not working, but we don't need it till the end.
%  assert {Gamma, u:tm, u1:of u Z1, u2:reduce u Z1 |- u2:reduce u Z1}.
%    apply weaken_ctx to H3 with (Gamma = Gamma, u:tm, u:of u Z1, u2:reduce u Z1).
%    apply weaken_ctx to H4 with (Gamma = Gamma, u:tm, u:of u Z1, u2:reduce u Z1).
%    apply weaken_ctx to H3 with (Gamma = Gamma, u:tm).
%    apply weaken_ctx to H4 with (Gamma = Gamma, u:tm).
%    apply weaken_ctx to H3 with (Gamma = Gamma, u:tm, u1:of u Z1).
%    apply weaken_ctx to H4 with (Gamma = Gamma, u:tm, u1:of u Z1).
%    search.
%
%  % prepare CR1
%  apply IH to H1.
%  apply H9 to H3 with (G13 = Gamma, u:tm, u1:of u Z1, u2:reduce u Z1).
%  case H10.
%  % MINORBUG: why hasn't u2 shown up in the nominals list? May be due to previous skips.
%  apply H11 to H8 with M1 = u, D1 = u2.

  % will probably have to change this later to have a weakened context, but I don't
  % *think* that will change anything.
  assert forall N U D10 D11,
      {Gamma |- N : nat} =>
      {Gamma |- D10 : sn N U} =>
      {Gamma |- D11 : reduce U Z1} =>
      exists D12, {Gamma |- D12 : reduce (app M2 U) Z2}.
    induction on 1. intros.

    assert forall M3 D3, {Gamma |- D3 : step (app M2 U) M3} =>
        exists D4, {Gamma |- D4 : reduce M3 Z2}.
      intros. case H11(keep).

      % step_beta case.
	assert exists D1, {Gamma |- D1 : eq_tm (lam T1 ([x]R x)) (lam T1 ([x]R x))}.
	    exists refl (lam T1 ([x]R x)). search.
	apply H6 to H15. case H16.
      % step_app2 case.
	assert exists D30, {Gamma |- D30 : reduce N' Z1}.
	    apply reduce_step to H10 H15.
	    exists D3. search.
	case H8(keep).
	assert exists D31, {Gamma |- D31 : sn n N'}.
	    apply sn_step__sn to H9.
	    apply H18 to H15.
	    exists D'. search.
	apply IH1 to H17 H18 H16.
	exists D12. search.
	% deal with nonsensical sn z U case.
	  case H9.
     % step_app1 case.
       apply H7 to H15.
       case H16.
       inst H21 with n = U.
       inst H22 with n1 = D11.
       exists (P U D11). search.
       % deal with if the reducible was in the context
         case H15.

         apply H7 to H15.
	 case H17.

         % This case recurses infinitely.
       

  % to be continued...
  abort.