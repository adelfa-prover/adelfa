This proof uses the following LF signature for the STLC, expressed in .elf
syntax:

ty : type.
arr : ty -> ty -> ty.

tm : type.
app : tm -> tm -> tm.
lam : ty -> (tm -> tm) -> tm.

of : tm -> ty -> type.
of_app : {M:tm}{N:tm}{T:ty}{U:ty}
          {a1:of M (arr U T)} {a2:of N U} of (app M N) T.
of_lam : {R : {x:tm} tm}{T:ty}{U:ty}
          {a1:({x:tm}{z:of x T} of (R x) U)}
          of (lam T ([x] R x)) (arr T U).

eval : tm -> tm -> type.
eval_abs  : {R:{x:tm} tm} {T:ty} eval (lam T R) (lam T R).
eval_beta : {M:tm} {N:tm} {V:tm} {R:{x:tm}tm} {T:ty}
            {D1 : eval M (lam T R)}
            {D2 : eval (R N) V}
            eval (app M N) V.

Because of this, judements such as Γ ⊢ d : of x t are derived by a series of
rules, especially including the b-app-obj and b-const-obj rules. However, the
following rules, which are actually composed of several LF rules (including
b-app-obj and b-const-obj) will be frequently used:

Γ, x:tm, d:of x t1 ⊢ d2 : of (r x) t2
======================================================================
Γ ⊢ of_lam r t1 t2 (λx:tm.λd:(of x t1).d2) : of (lam t1 r) (arr t1 t2)

Subject Reduction: for all contexts Γ constructed from blocks of the form (x :
tm, d : of x T), for all terms m1, m2, t, d1 and d2,

Γ ⊢ d1 : of m1 t ==> d2 : m1 → m2 ==> ∃d3, Γ ⊢ d3 : of m2 t

Proof:

We will prove this by induction of the height of the derivation tree for the
type judgement of d2. Proceed by cases on the final reduction rule used.


