Specification "reduce.elf".

Schema c :=
 {T}(x:tm,y:of x T).

Schema red :=
 {T}(x:tm,y:reduce x T).

Theorem uniq_lemma : ctx Gamma:c, forall T,
  {Gamma |- T : ty} => {T : ty}.

  induction on 1. intros. case H1.

  % arr case
  apply IH to H2.
  apply IH to H3.
  search.

  % top case.
  search.

Theorem uniq_type : ctx Gamma:c, forall M T1 T2 D1 D2,
  {Gamma |- D1 : of M T1} => {Gamma |- D2 : of M T2} => exists D3,
  {D3 : eq_ty T1 T2}.

  induction on 1. intros. case H1.

  % of-lam case
  case H2.
  apply IH to H6 H12.
  case H15.
  apply uniq_lemma to H10.
  exists refl_ty (arr T U1).
  search.

  % of-app case
  case H2.
  apply IH to H7 H15.
  case H19.
  case H20.
  exists refl_ty T2.
  search.

  % var case
  case H2.
  apply uniq_lemma to H4.
  exists refl_ty T.
  search.

Theorem sn_step : forall M1 M2 D1 D2,
  {D1 : sn M1} => {D2 : step M1 M2} => exists D3,
  {D3 : sn M2}.

  intros. case H1.
  assert {M2 : tm}. case H2. search. search. search. search.
  inst H4 with n = M2.
  inst H7 with n1 = D2.
  exists (D M2 D2).
  search.

% Still has a skip, but I'll give another shot at solving this.
Theorem sr : ctx Gamma:c, forall M1 M2 T D1 D2,
  {Gamma |- D1 : step M1 M2} => {Gamma |- D2 : of M1 T} => exists D3,
  {Gamma |- D3 : of M2 T}.

  induction on 1. intros. case H1.

  % step-lam case
  case H2.
  apply IH to H6 H12.

  % why does this fail?
  exists of_lam ([x] R2 x) T1 U ([x] [x1] D3).
  search.

%  % this works
%   assert {Gamma |- lam : {e:ty} {d:{a: tm} tm} tm}.
%   search.
%  
%  % a successful attempt to verify a partial version of a lambda term.
%   assert {Gamma |- lam T1 : {d:{a: tm} tm} tm}.
%   weaken H3 with ({a:tm}tm).
%   search.
%  
%  % this works.
%  assert {Gamma |- ([x] [x1] D3) : {y:tm} {y1:of y T1} of (R2 y) U}.
%  search.
%  
%  % a failed attempt to prove a partial section of the proof by repeatedly weakening.
%   assert {Gamma |- of_lam R2 : {T3:ty} {U3:ty} {a3:({x:tm}{z:of x T3} of (R2 x) U3)} of (lam T3 ([x] R2 x)) (arr T3 U3)}.
%   search.
%   weaken H5 with ty.
%   weaken H17 with ty.
%   % weakening fails.
%   weaken H18 with ({x:tm}{z:of x n1} of (R2 x) n2).
%   skip.


  % the other cases.
  skip.

  % step-beta case
  case H2.
  case H12.
  inst H19 with n = N.
  inst H22 with n1 = a2.
  exists (a3 N a2).
  search.

  % step-app2 case
  case H2.
  apply IH to H6 H14.
  exists of_app M N2 T U a1 D3.
  search.

  % step-app1 case
  case H2.
  apply IH to H6 H13.
  exists of_app M4 N T U D3 a2.
  search.

Theorem cr2: ctx Gamma:c, forall M1 M2 T D1 D2,
  {T:ty} => {Gamma |- D1 : reduce M1 T} => {Gamma |- D2 : step M1 M2} => exists D3,
  {Gamma |- D3 : reduce M2 T}.

  induction on 1. intros. case H2.

  % arrow case.
  assert {Gamma |- M2 : tm}.
  case H3. search. search. search. search.

  assert exists D5, {Gamma, n:tm, n1:reduce n T1 |- D5 : step (app M1 n) (app M2 n)}.
    weaken H3 with tm.
    weaken H4 with tm.
    weaken H12 with (reduce n T1).

    weaken H6 with tm.
    weaken H15 with (reduce n T1).

    weaken H11 with tm.
    weaken H17 with (reduce n T1).
    
    exists step-app1 M1 M2 n D2.

    search.
  case H1.
  apply IH to H14 H8 H12.

  apply sr to H3 H7.
  
  exists reduce-abs T1 T2 M2 D6 ([x] [x1] D1).
  search.
  
  % top case.
  case H6.
  assert {Gamma |- M2 : tm}.
  case H3. search. search. search. search.
  inst H10 with n = M2.
  inst H13 with n1 = D2.
  apply sr to H3 H5.
  exists reduce-top M2 D1 (D M2 D2).
  search.

Theorem neutral_lemma: ctx Gamma:c, forall T, {Gamma, n:tm, n1:of n T |- n1:of n T} =>
  (forall T0 R0, (exists D, {Gamma, n:tm, n1:of n T |- D : eq_tm n (lam T0 R0)}) => false).
  intros.
  case H2.

Theorem cr1_cr3 : ctx Gamma:c, forall T, {T : ty} =>
  (forall M D1, {Gamma |- D1 : reduce M T} => exists D2, {D2 : sn M}) /\
  (forall M1, (forall T0 R0, (exists D1, {Gamma |- D1 : eq_tm M1 (lam T0 R0)} => false)) =>
      (forall M2 D2, {Gamma |- D2 : step M1 M2} => exists D3, {Gamma |- D3 : reduce M2 T}) =>
    exists D4, {Gamma |- D4 : reduce M1 T}).

  induction on 1. intros. split.

  % cr1
  intros. case H1.

  % arrow case
  case H2.
  apply IH to H4.
  case H12.
  apply IH to H3.
  case H15.

  assert exists D10, {Gamma, n:tm, n1:of n Z1 |- D10 : reduce n Z1}.
    assert forall M10 D20, {Gamma, n:tm, n1: of n Z1 |- D20 : step n M10} =>
             exists D30, {Gamma, n:tm, n1 : of n Z1 |- D30 : reduce M10 Z1}.
      intros.
      case H18.

    assert {Gamma, n:tm, n1:of n Z1 |- n1:of n Z1}.
      weaken H5 with tm. search.
    apply neutral_lemma to H19.

    % application fails
    apply H17 to H20 H18.
    skip.



  abort.

% ADDED 10/30
Theorem ctx_and_test : forall T, {T : ty} => ctx Gamma:c,
  (forall M D1, {Gamma |- D1 : of M T} => exists D2, {Gamma |- D2 : of M T}) /\
  (forall M1 M2 D3, {Gamma |- D3 : step M1 M2} => exists D4, {Gamma |- D4 : step M1 M2}).

  induction on 1. intros. case H1.

  apply IH to H3.
  split.
  intros.

  % does nothing.
  case H4.
 

  % some other stuff I tried.
  case H5.

  assert (forall M D1, {Gamma, n:tm, n1:of n Z2 |- D1 : of M Z2} => exists D2, {Gamma, n:tm, n1:of n Z2 |- D2 : of M Z2})
     /\
     (forall M1 M2 D3, {Gamma, n:tm, n1:of n Z2 |- D3 : step M1 M2} => exists D4, {Gamma, n:tm, n1:of n Z2 |- D4 : step M1 M2}).

  split.
  intros.

  assert exists M1 M2 D3, {Gamma, n:tm, n1:of n Z2 |- D3 : step M1 M2}. skip.

  % error: expects H4 to be applied to 0 arguments.
  apply H4 to H12 H13.

  % error: "structure of applied term must be a substructure of the the following".
  apply H4 to H12 H13 with (G2 = Gamma, n:tm, n1:of n Z2).

  abort.


Theorem cr1_cr3v2 : forall T, {T : ty} => ctx Gamma:c,
  (forall M D1, {Gamma |- D1 : reduce M T} => exists D2, {D2 : sn M}) /\
  (forall M1, (forall T0 R0, (exists D1, {Gamma |- D1 : eq_tm M1 (lam T0 R0)} => false)) =>
      (forall M2 D2, {Gamma |- D2 : step M1 M2} => exists D3, {Gamma |- D3 : reduce M2 T}) =>
    exists D4, {Gamma |- D4 : reduce M1 T}).

  induction on 1. intros. split.

  % cr1
  intros. case H1.

  % arrow case
  case H2.
  apply IH to H4.
  apply IH to H3.

  % doesn't work.
  case H13.

  assert exists D10, {Gamma, n:tm, n1:of n Z1 |- D10 : reduce n Z1}.
    assert forall M10 D20, {Gamma, n:tm, n1: of n Z1 |- D20 : step n M10} =>
             exists D30, {Gamma, n:tm, n1 : of n Z1 |- D30 : reduce M10 Z1}.
      intros.
      case H14.
    assert {Gamma, n:tm, n1:of n Z1 |- n1:of n Z1}.
      weaken H5 with tm. search.
      apply neutral_lemma to H15.


    % attempt to show the other part of the IH even though we don't need it.
    assert forall M40 D40, {Gamma, n:tm, n1:of n Z1 |- D40 : reduce M40 Z1} => exists D41, {D41 : sn M40}.
      intros.
      apply H13 to H17 H16 H14 with (G4 = Gamma, n:tm, n1:of n Z1).

  abort.
