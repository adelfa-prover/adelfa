Specification "reduce.elf".

Schema c :=
 {T}(x:tm,y:of x T).

Schema red :=
 {T}(x:tm,y:reduce x T).

Theorem sr_inst_attempt : ctx Gamma:c, forall M1 M2 T D1 D2,
  {Gamma |- D1 : step M1 M2} => {Gamma |- D2 : of M1 T} => exists D3,
  {Gamma |- D3 : of M2 T}.

  induction on 1. intros. case H1.

  % step-lam case
  case H2.
  apply IH to H6 H12.

  % 0 applications: works
  % in addition, I'm going to try solving the issue by instantiating the result of this.
  assert {Gamma |- of_lam : {R : {x:tm} tm}{T:ty}{U:ty}{a1:({x:tm}{z:of x T} of (R x) U)} of (lam T ([x] R x)) (arr T U)}.
  search.

%  % 1 application, an application of R2 : {x:tm} tm fails.
%  % But this is commented out because I want to try instantiation instead...
%  assert {Gamma |- (of_lam R2) : {T:ty}{U:ty}{a1:({x:tm}{z:of x T} of (R2 x) U)} of (lam T (R2)) (arr T U)}. search.

  % I believe getting the 1-app version to work needs a proof of R2 : {x:tm} tm
  % except with that incredibly weakened context, so lets try weakening it.
  weaken H5 with ty.
  weaken H17 with ty.

  % needs {Gamma, n:tm, n1:ty, n2:ty, n3:tm, n4:of n3 n1 |- R2 n3 : tm}
    weaken H18 with tm.
    ctxpermute H19 to Gamma, n3:tm, n1:ty, n2:ty, n:tm.

    % this changes n to o instead of o->o in the nominals list??
    % and it seems to be necessary to make the next statement succeed???
    weaken H3 with tm.

    weaken H20 with (of n n1).

  weaken H18 with ({x:tm}{z:of x n1} of (R2 x) n2).

  % nope, still fails.
  search.

  % try a different tactic: instantiations. It works!
  % also why did this reverse the context? in H24 n3 now comes before n1 & n2 in the context.
  % what is up with that?
  % also: check out H24, the type of n3 includes n2 in it.
  % yet n2 shows up later in the context. ??
  inst H16 with n = R2.

  % search still fails just as before, but let's try more instantiation...
  search.

  % since the context was messed up by the inst, get it back in place.
  ctxpermute H24 to Gamma, n1:ty, n2:ty, n3:{x:tm}{z:of x n1} of (R2 x) n2.

  % OK, do another instantiation.
  inst H25 with n1 = T1.

  % Once again, the context is messed up in H26 in a way that seems illegal
  % since n3's type includes n2 yet n2 occurs later in the context
  % so let's fix it and do another instantiation.
  ctxpermute H26 to Gamma, n2:ty, n3:{x:tm}{z:of x T1}of (R2 x) n2.
  inst H27 with n2 = U.

  % haha, can't mess up a context with only Gamma and n3!
  % anyway, instantiate this:
  inst H28 with n3 = [x] [x1] D3.

  exists (of_lam ([c22]R2 c22) T1 U ([c24][c25]D3)).

  % so this search fails.
  % yet H29 has a form identical to what it is searching for...
  % with the only difference being [x]R2 x instead of R2.
  search.

  abort.

%Theorem sr_new : ctx Gamma:c, forall M1 M2 T D1 D2,
%  {Gamma |- D1 : step M1 M2} => {Gamma |- D2 : of M1 T} => exists D3,
%  {Gamma |- D3 : of M2 T}.
%
%  induction on 1. intros. case H1.
%
%  % step-lam case
%  case H2.
%  apply IH to H6 H12.
%
%  assert {Gamma |- of_lam : {r : {x:tm} tm}{t1:ty}{t2:ty}{a1:({x:tm}{z:of x t1} of (r x) t2)} of (lam t1 ([x] r x)) (arr t1 t2)}.
%  search.
%
%  % 1 application.
%  % Try getting a really weak context typing R2.
%  assert {Gamma |- (of_lam R2) : {t1:ty}{t2:ty}{a1:({x:tm}{z:of x t1} of (R2 x) t2)} of (lam t1 (R2)) (arr t1 t2)}. search.
%
%
%  % I believe getting the 1-app version to work needs a proof of R2 : {x:tm} tm
%  % except with that incredibly weakened context, so lets try weakening it.
%  weaken H5 with ty.
%  weaken H17 with ty.
%
%  % needs {Gamma, n:tm, n1:ty, n2:ty, n3:tm, n4:of n3 n1 |- R2 n3 : tm}
%    weaken H18 with tm.
%    ctxpermute H19 to Gamma, n3:tm, n1:ty, n2:ty, n:tm.
%
%    % this changes n to o instead of o->o in the nominals list??
%    % and it seems to be necessary to make the next statement succeed???
%    weaken H3 with tm.
%
%    weaken H20 with (of n n1).
%
%  weaken H18 with ({x:tm}{z:of x n1} of (R2 x) n2).
%
%  % nope, still fails.
%  search.
%
%  % maybe send n to the end of the context? nope.
%  ctxpermute H23 to Gamma, n1:ty, n2:ty, n3:{x:tm}{z:of x n1}of (R2 x) n2, n:tm.
%  search.
%
%  
%
%
%  % instantiations track.
%
%  % try a different tactic: instantiations. It works!
%  % also why did this reverse the context? in H24 n3 now comes before n1 & n2 in the context.
%  % what is up with that?
%  % also: check out H24, the type of n3 includes n2 in it.
%  % yet n2 shows up later in the context. ??
%  inst H16 with n = R2.
%
%  % search still fails just as before, but let's try more instantiation...
%  search.
%
%  % since the context was messed up by the inst, get it back in place.
%  ctxpermute H24 to Gamma, n1:ty, n2:ty, n3:{x:tm}{z:of x n1} of (R2 x) n2.
%
%  % OK, do another instantiation.
%  inst H25 with n1 = T1.
%
%  % Once again, the context is messed up in H26 in a way that seems illegal
%  % since n3's type includes n2 yet n2 occurs later in the context
%  % so let's fix it and do another instantiation.
%  ctxpermute H26 to Gamma, n2:ty, n3:{x:tm}{z:of x T1}of (R2 x) n2.
%  inst H27 with n2 = U.
%
%  % haha, can't mess up a context with only Gamma and n3!
%  % anyway, instantiate this:
%  inst H28 with n3 = [x] [x1] D3.
%
%  exists (of_lam ([c22]R2 c22) T1 U ([c24][c25]D3)).
%
%  % so this search fails.
%  % yet H29 has a form identical to what it is searching for...
%  % with the only difference being [x]R2 x instead of R2.
%  search.
%
%
%%   % why does this fail?
%%   exists of_lam ([x] R2 x) T1 U ([x] [x1] D3).
%%   search.
%% 
%% %  % this works
%% %   assert {Gamma |- lam : {e:ty} {d:{a: tm} tm} tm}.
%% %   search.
%% %  
%% %  % a successful attempt to verify a partial version of a lambda term.
%% %   assert {Gamma |- lam T1 : {d:{a: tm} tm} tm}.
%% %   weaken H3 with ({a:tm}tm).
%% %   search.
%% %  
%% %  % this works.
%% %  assert {Gamma |- ([x] [x1] D3) : {y:tm} {y1:of y T1} of (R2 y) U}.
%% %  search.
%% %  
%%   % a failed attempt to prove a partial section of the proof by repeatedly weakening.
%%    assert {Gamma |- of_lam R2 : {T3:ty} {U3:ty} {a3:({x:tm}{z:of x T3} of (R2 x) U3)} of (lam T3 ([x] R2 x)) (arr T3 U3)}.
%%    search.
%%    weaken H5 with ty.
%%    weaken H17 with ty.
%%    % weakening fails.
%%    weaken H18 with ({x:tm}{z:of x n1} of (R2 x) n2).
%%    skip.
%
%
%  % the other cases.
%  skip.
%
%  % step-beta case
%  case H2.
%  case H12.
%  inst H19 with n = N.
%  inst H22 with n1 = a2.
%  exists (a3 N a2).
%  search.
%
%  % step-app2 case
%  case H2.
%  apply IH to H6 H14.
%  exists of_app M N2 T U a1 D3.
%  search.
%
%  % step-app1 case
%  case H2.
%  apply IH to H6 H13.
%  exists of_app M4 N T U D3 a2.
%  search.
%
%Theorem sr_take3 : ctx Gamma:c, forall M1 M2 T D1 D2,
%  {Gamma |- D1 : step M1 M2} => {Gamma |- D2 : of M1 T} => exists D3,
%  {Gamma |- D3 : of M2 T}.
%
%  induction on 1. intros. case H1.
%
%  % step-lam case
%  case H2.
%  apply IH to H6 H12.
%
%% attempt when of_lam has been switched so R is not first.
%%   assert {Gamma |- of_lam T1 U R2 : {a5:({x:tm}{z:of x T1} of (R2 x) U)} of (lam T1 R2) (arr T1 U)}.
%%   weaken
%
%
%  % the right thing.
%  % exists of_lam R2 T1 U ([x] [x1] D3).
%
%  % the wrong thing.
%  exists of_lam R2 T1 U ([x] [x1] D3).
%  search.
%
%  % get to the other cases.
%  skip.
%
%  % step-beta case
%  case H2.
%  case H12.
%  inst H19 with n = N.
%  inst H22 with n1 = a2.
%  exists (a3 N a2).
%  search.
%
%% The correct step-app2 case.
%%   % step-app2 case
%%   case H2.
%%   apply IH to H6 H14.
%%   exists of_app M N2 T U a1 D3.
%%   search.
%
%  % alternate step-app2 case
%  % only fills in one argument.
%  case H2.
%  apply IH to H6 H14.
%  assert {Gamma |- of_app M : {b:tm}{c:ty}{d:ty}{e:of M (arr d c)}{f:of b d} of (app M b) c}.
%  weaken H3 with tm.
%  weaken H18 with ty.
%  weaken H19 with ty.
%  weaken H20 with (of M (arr n2 n1)).
%  weaken H21 with (of n n2).
%  search.
%
%  % alternate step-app2 case
%  % tries a partial application, leaving 1 of_app argument blank.
%  % when I finally search correctly, checkout what it goes through.
%  case H2.
%  apply IH to H6 H14.
%  assert {Gamma |- of_app M N2 T U a1 : {y:of N2 U} of (app M N2) T}.
%  weaken H3 with (of N2 U).
%  weaken H5 with (of N2 U).
%  weaken H11 with (of N2 U).
%  weaken H12 with (of N2 U).
%  weaken H13 with (of N2 U).
%  search.
%  inst H18 with n = D3.
%  exists of_app M N2 T U a1 D3.
%  search.
%
%  % step-app1 case
%  case H2.
%  apply IH to H6 H13.
%  exists of_app M4 N T U D3 a2.
%  search.

Theorem sr : ctx Gamma:c, forall M1 M2 T D1 D2,
  {Gamma |- D1 : step M1 M2} => {Gamma |- D2 : of M1 T} => exists D3,
  {Gamma |- D3 : of M2 T}.

  induction on 1. intros. case H1.

  % step-lam case
  case H2.
  apply IH to H6 H12.

  % the right thing.
  % exists of_lam R2 T1 U ([x] [x1] D3).

  % the wrong thing.
  exists of_lam R2 T1 U ([x] [x1] D3).
  search.

  % get to the other cases.
  skip.

  % step-beta case
  case H2.
  case H12.
  inst H19 with n = N.
  inst H22 with n1 = a2.
  exists (a3 N a2).
  search.

 %The correct step-app2 case.
   % step-app2 case
   case H2.
   apply IH to H6 H14.
   exists of_app M N2 T U a1 D3.
   search.

%  % alternate step-app2 case
%  % only fills in one argument.
%  case H2.
%  apply IH to H6 H14.
%  assert {Gamma |- of_app M : {b:tm}{c:ty}{d:ty}{e:of M (arr d c)}{f:of b d} of (app M b) c}.
%  weaken H3 with tm.
%  weaken H18 with ty.
%  weaken H19 with ty.
%  weaken H20 with (of M (arr n2 n1)).
%  weaken H21 with (of n n2).
%  search.
%
%  % alternate step-app2 case
%  % tries a partial application, leaving 1 of_app argument blank.
%  % when I finally search correctly, checkout what it goes through.
%  case H2.
%  apply IH to H6 H14.
%  assert {Gamma |- of_app M N2 T U a1 : {y:of N2 U} of (app M N2) T}.
%  weaken H3 with (of N2 U).
%  weaken H5 with (of N2 U).
%  weaken H11 with (of N2 U).
%  weaken H12 with (of N2 U).
%  weaken H13 with (of N2 U).
%  search.
%  inst H18 with n = D3.
%  exists of_app M N2 T U a1 D3.
%  search.

  % step-app1 case
  case H2.
  apply IH to H6 H13.
  exists of_app M4 N T U D3 a2.
  search.
