Specification "reduce.elf".

Schema c :=
 {T}(x:tm,y:of x T).

Schema red :=
 {T}(x:tm,y:reduce x T).

Theorem uniq_lemma : ctx Gamma:c, forall T,
  {Gamma |- T : ty} => {T : ty}.

  induction on 1. intros. case H1.

  % arr case
  apply IH to H2.
  apply IH to H3.
  search.

  % top case.
  search.

Theorem uniq_type : ctx Gamma:c, forall M T1 T2 D1 D2,
  {Gamma |- D1 : of M T1} => {Gamma |- D2 : of M T2} => exists D3,
  {D3 : eq_ty T1 T2}.

  induction on 1. intros. case H1.

  % of-lam case
  case H2.
  apply IH to H6 H12.
  case H15.
  apply uniq_lemma to H10.
  exists refl_ty (arr T U1).
  search.

  % of-app case
  case H2.
  apply IH to H7 H15.
  case H19.
  case H20.
  exists refl_ty T2.
  search.

  % var case
  case H2.
  apply uniq_lemma to H4.
  exists refl_ty T.
  search.

% Theorem sn_step : forall M1 M2 D1 D2,
%   {D1 : sn M1} => {D2 : step M1 M2} => exists D3,
%   {D3 : sn M2}.
% 
%   intros. case H1.
%   assert {M2 : tm}. case H2. search. search. search. search.
%   inst H4 with n = M2.
%   inst H7 with n1 = D2.
%   exists (D M2 D2).
%   search.

Theorem sr : ctx Gamma:c, forall M1 M2 T D1 D2,
  {Gamma |- D1 : step M1 M2} => {Gamma |- D2 : of M1 T} => exists D3,
  {Gamma |- D3 : of M2 T}.

  induction on 1. intros. case H1.

  % step-lam case
  case H2.
  apply IH to H6 H12.

%   % why does this fail?
%   exists of_lam ([x] R2 x) T1 U ([x] [x1] D3).
%   search.
% 
% %  % this works
% %   assert {Gamma |- lam : {e:ty} {d:{a: tm} tm} tm}.
% %   search.
% %  
% %  % a successful attempt to verify a partial version of a lambda term.
% %   assert {Gamma |- lam T1 : {d:{a: tm} tm} tm}.
% %   weaken H3 with ({a:tm}tm).
% %   search.
% %  
% %  % this works.
% %  assert {Gamma |- ([x] [x1] D3) : {y:tm} {y1:of y T1} of (R2 y) U}.
% %  search.
% %  
%   % a failed attempt to prove a partial section of the proof by repeatedly weakening.
%    assert {Gamma |- of_lam R2 : {T3:ty} {U3:ty} {a3:({x:tm}{z:of x T3} of (R2 x) U3)} of (lam T3 ([x] R2 x)) (arr T3 U3)}.
%    search.
%    weaken H5 with ty.
%    weaken H17 with ty.
%    % weakening fails.
%    weaken H18 with ({x:tm}{z:of x n1} of (R2 x) n2).
%    skip.


  % the other cases.
  skip.

  % step-beta case
  case H2.
  case H12.
  inst H19 with n = N.
  inst H22 with n1 = a2.
  exists (a3 N a2).
  search.

  % step-app2 case
  case H2.
  apply IH to H6 H14.
  exists of_app M N2 T U a1 D3.
  search.

  % step-app1 case
  case H2.
  apply IH to H6 H13.
  exists of_app M4 N T U D3 a2.
  search.

Theorem cr2: ctx Gamma:c, forall M1 M2 T D1 D2,
  {T:ty} => {Gamma |- D1 : reduce M1 T} => {Gamma |- D2 : step M1 M2} => exists D3,
  {Gamma |- D3 : reduce M2 T}.

  induction on 1. intros. case H2.

  % arrow case.
  assert {Gamma |- M2 : tm}.
  case H3. search. search. search. search.

  assert exists D5, {Gamma, n:tm, n1:reduce n T1 |- D5 : step (app M1 n) (app M2 n)}.
    weaken H3 with tm.
    weaken H4 with tm.
    weaken H12 with (reduce n T1).

    weaken H6 with tm.
    weaken H15 with (reduce n T1).

    weaken H11 with tm.
    weaken H17 with (reduce n T1).
    
    exists step-app1 M1 M2 n D2.

    search.
  case H1.
  apply IH to H14 H8 H12.

  % QUESTION: why does this work, even with different contexts?
  apply sr to H3 H7.
  
  exists reduce-abs T1 T2 M2 D6 ([x] [x1] D1).
  search.
  
  % top case.
  case H6.
  assert {Gamma |- M2 : tm}.
  case H3. search. search. search. search.
  inst H10 with n = M2.
  inst H13 with n1 = D2.
  apply sr to H3 H5.
  exists reduce-top M2 D1 (D M2 D2).
  search.

Theorem empty_false : ctx Gamma:c, forall M, {Gamma |- M : empty} => false.
  intros.
  case H1.

Theorem var_neutral: ctx Gamma:red, exists D, {Gamma, n:tm |- D : neutral n}.
  intros.
  abort.

Theorem adelfa_neutral: ctx Gamma:c, forall T R D, {Gamma, n:tm, n1:of n T |- D : eq_tm n (lam T R)} => false.
  intros. case H1.

Theorem neutral_lemma: ctx Gamma:c, forall T, {Gamma, n:tm, n1:of n T |- n1:of n T} =>
  (forall T0 R0, (exists D1, {Gamma, n:tm, n1:of n T |- D1 : eq_tm n (lam T0 R0)}) => false).
  intros.
  case H2.

Theorem neutral_lemma_wrong_names: ctx Gamma:c, forall T, {Gamma, n:tm, n1:of n T |- n1:of n T} =>
  (forall T00 R00, (exists D, {Gamma, n:tm, n1:of n T |- D : eq_tm n (lam T00 R00)}) => false).
  intros.
  case H2.

Schema sn_ctx :=
 {M}(x:tm,y:sn M).

Theorem sn_app_name_clash : ctx Gamma:sn_ctx, forall M1 M2 D1, {Gamma |- D1 : sn (app M1 M2)} => exists D2,
  {Gamma |- D2 : sn M1}.

  induction on 1. intros. case H1.

  % H3 should have n1:step (app M1 M2) n, instead it has n1:step (app M1 n) n
  % Changing M2 to M3 in the statement of sn_app fixes the problem,
  % but shouldn't be necessary.
  % Note that sn is defined as follows, using the name M2:
  % sn : tm -> type.
  % sn-m : {M1:tm} {D : {M2:tm} {D1 : step M1 M2} sn M2} sn M1.

  abort.

Theorem sn_app_v0 : ctx Gamma:sn_ctx, forall M1 M3 D1, {Gamma |- D1 : sn (app M1 M3)} => exists D2,
  {Gamma |- D2 : sn M1}.

  induction on 1. intros. case H1. case H2.

  weaken H3 with tm.

  weaken H5 with tm.
  weaken H6 with tm.
  weaken H8 with (step (app M1 M3) n).
  weaken H10 with tm.
  weaken H7 with (step M1 n2).

  assert exists D4, {Gamma, n:tm, n1:step (app M1 M3) n, n2:tm, n3:step M1 n2 |- D4 : (step (app M1 M3) (app n2 M3))}.

  exists step-app1 M1 n2 M3 n3.

  weaken H11 with (step M1 n2).
  weaken H9 with (step (app M1 M3) n).
  weaken H14 with tm.
  weaken H15 with (step M1 n2).

  weaken H11 with (step M1 n2).

  weaken H9 with tm.
  weaken H8 with tm.
  weaken H14 with (step (app M1 M3) n).
  weaken H14 with tm.
  weaken H15 with (step M1 n2).

  search.

  ctxpermute H12 to Gamma, n2:tm, n3:step M1 n2, n:tm, n1:step (app M1 M3) n.

  weaken H9 with (step M1 n).

  % These two instantiations correspond to `apply H2 to H4` from the Abella version.
  % However, in Abella that does not remove inductive eligibility.
  % In fact, in Abella it didn't matter that H4 didn't have inductive eligibility.
  inst H14 with n = (app n2 M3).

  ctxpermute H13 to Gamma, n2:tm, n3:step M1 n2, n:tm, n1:step (app M1 M3) n.
  strengthen H17.
  strengthen H18.

  inst H16 with n1 = D4.

  % fails due to inductive restriction violation.
  apply IH to H20.

  abort.
 
Theorem cr1_cr3 : ctx Gamma:c, forall T, {T : ty} =>
  (forall M D1, {Gamma |- D1 : reduce M T} => exists D2, {D2 : sn M}) /\
  (forall M1, (forall T0 R0, (exists D1, {Gamma |- D1 : eq_tm M1 (lam T0 R0)}) => false) =>
      (forall M2 D20, {Gamma |- D20 : step M1 M2} => exists D3, {Gamma |- D3 : reduce M2 T}) =>
    exists D4, {Gamma |- D4 : reduce M1 T}).

  induction on 1. intros. split.

  % cr1
  intros. case H1.

  % arrow case
  case H2.

  % The recursive application of CR3
  assert exists D10, {Gamma, n:tm, n1:of n Z1 |- D10 : reduce n Z1}.
    assert forall M2 D20, {Gamma, n:tm, n1: of n Z1 |- D20 : step n M2} =>
             exists D3, {Gamma, n:tm, n1 : of n Z1 |- D3 : reduce M2 Z1}.
      intros. case H12.

    assert {Gamma, n:tm, n1:of n Z1 |- n1:of n Z1}.
      weaken H5 with tm. search.

    % NOTE1: switch this to neutral_lemma_wrong_names, and the `apply H17` statement fails.
    % apply neutral_lemma_wrong_names to H13 with T = Z1.
    apply neutral_lemma to H13 with T = Z1.


    % Adelfa allows this. But wait, doesn't Gamma, n:tm not fit schema c?
    % apply IH to H3 with (Gamma = Gamma, n:tm).

    apply IH to H3 with (Gamma = Gamma, n:tm, n1:of n Z1).
    case H15.

    apply H17 to H14 H12 with M1 = n.
    % ^ works just as well without the  `with M1 = n`:
    % apply H17 to H14 H12.

    exists D4. search.

  weaken H5 with tm. weaken H13 with (reduce n Z1). weaken H9 with (of n Z1).
  ctxpermute H15 to Gamma, n:tm, n2:of n Z1, n1:reduce n Z1.
  inst H16 with n1 = D10.

  % The recursive application of CR1
  % wait, this works? why does n have meaning in judgements that don't include it
  % in a context?
  assert exists D100, {D100 : sn (app M n)}.
    apply IH to H4 with (Gamma = Gamma, n:tm, n2:of n Z1).
    case H18.
    apply H19 to H17.
    exists D1. search.

  % To be continued...
  abort.
