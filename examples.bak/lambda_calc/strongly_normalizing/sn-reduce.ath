Specification "sn-alt.lf".

Schema c :=
 {T}(x:tm,y:of x T).
 
%% sanity check:
%% if a term is strongly normalizing for some N, then is strongly normalizing for any larger N
Theorem sn_n__sn_sn :
ctx G:c, forall N M D, {G |- D : sn N M} => exists D', {G |- D' : sn (s N) M}.
induction on 1. intros. case H1. apply IH to H4.
assert {G |- s N1 : nat}. search.
exists sn_tm (s N1) M  ([x][y]D' y x). search.

%% The following two theorems let us omit some assumptions about
%% typing which can be infered from other assumption derivations
Theorem step__tm :
ctx G:c, forall M N D, {G |- D : step M N} => {G |- M : tm} /\ {G |- N : tm}.
induction on 1. intros. case H1.
  %case 1: step_lam
    apply IH to H5. case H6. split. search. search.
  %case 2: step_beta
    split. search. inst H3 with n = M1. search.
  %case 3: step_app2
    apply IH to H5. case H6. split. search. search.
  %case 4: step_app1
    apply IH to H5. case H6. split. search. search.
    
Theorem sn__nat_tm :
ctx G:c, forall N M D, {G |- D : sn N M} => {G |- N : nat} /\ {G |- M : tm}.
intros. case H1. split. search. search.

%Formulas for sn:
%(ctx G:c, forall N M,
%    {G |- M : tm} =>
%    (forall M' D, {G |- D : step M M'} => exists D', {G |- D' : sn N M'}) =>
%        exists D, {G |- D : sn (s N) M})
% and
%(ctx G:c, forall N M D,
%    {G |- D : sn (s N) M} =>
%        forall M' D, ({G |- D : step M M'} => exists D', {G |- D' : sn N M'}))
%% The later of these formulas can be proved directly in the logic using instantiation.
Theorem sn_step__sn : ctx G:c, forall N M D,
    {G |- D : sn (s N) M} =>
        forall M' D, ({G |- D : step M M'} => exists D', {G |- D' : sn N M'}).
intros. case H1. apply step__tm to H2. case H6.
inst H5 with n = M'. inst H9 with n1 = D1.
exists (P M' D1). search.

%% reduction steps preserve typing (subject reduction)
Theorem of_step : ctx G:c, forall M M' T D1 D2,
{G |- D1 : of M T} => {G |- D2 : step M M'} => exists D3, {G |- D3 : of M' T}.
induction on 2. intros. case H2.
  %case 1: step_lam
    case H1. apply IH to H10 H6. prune H11.
    exists (of_lam ([x]R' x) T1 T2 ([x][y]D1 y x)). search.
  %case 2: step_beta
    case H1. case H10.
    inst H15 with n2 = M1. inst H16 with n3 = D5.
    exists (D6 M1 D5). search.
  %case 3: step_app2
    case H1. apply IH to H12 H6.
    exists (of_app M1 N' T U a1 D3). search.
  %case 4: step_app1
    case H1. apply IH to H11 H6.
    exists (of_app M'1 N T U D3 a2). search.

%% sn is preserved by reduction steps (essentially just the meaning of sn)
Theorem sn_step : ctx G:c, forall N M M' D1 D2,
{G |- D1 : sn (s N) M} => {G |- D2 : step M M'} => exists D3, {G |- D3 : sn N M'}.
intros. case H1. apply step__tm to H2. case H6. inst H5 with n = M'. inst H9 with n1 = D2.
exists (P M' D2). search.

%%CR2
Theorem reduce_step :
ctx G:c, forall M M' T D1 D2,
    {G |- D1 : reduce M T} => {G |- D2 : step M M'} => exists D3, {G |- D3 : reduce M' T}.
induction on 1. intros. apply step__tm to H2. case H3. case H1.
  %case 1: reduce_arr
    %%%to obtain the typing judgement {G |- D : of N (arr A B)}
      apply of_step to H9 H2. prune H11.
    %%%to obtain the reducibility judgement {G |- [x][y] D x y : {x:tm}{y:of x A}reduce (app M' x) B}
      assert {G, n:tm, n1:reduce n A |- step_app1 M n M' D2 : step (app M n) (app M' n)}.
        weaken H7 with tm. weaken H4 with tm. weaken H13 with (reduce n3 A).
        weaken H5 with tm. weaken H15 with (reduce n5 A).
        weaken H2 with tm. weaken H17 with (reduce n7 A).
        search.
      apply IH to H10 H12.
      exists (reduce_arr M' A B D3 ([x][y]D1 y x)). search.
  %case 2: reduce_top
    apply of_step to H8 H2. apply sn_n__sn_sn to H9. apply sn_step to H11 H2.
    exists (reduce_top N M' D3 D1). search.

%%% sn (app M x) => sn M
Theorem sn_app_c :
(ctx G:c, forall N M,
    {G |- M : tm} =>
    (forall M' D, {G |- D : step M M'} => exists D', {G |- D' : sn N M'}) =>
        exists D, {G |- D : sn (s N) M}) => 
ctx G:c, forall N M x D,
{G |- N : nat} => {G |- D : sn N (app M x)} => exists D, {G |- D : sn N M}.
induction on 2. intros. case H3(keep). case H2(keep).
%%%% using the lemma sn_step__sn to move from sn derivation to formula
apply sn_step__sn to H3.
%%%% show the key property of being strongly normalizing: anything M steps to is strongly normalizing
assert (forall M' D, {G |- D : step M M'} => exists D', {G |- D' : sn N1 M'}).
  intros. prune H9. apply step__tm to H9. case H10. prune H12.
  assert {G |- step_app1 M x M' D: step (app M x) (app M' x)}.
    case H5. search.
  apply H8 to H13. prune H14.
  apply IH to H1. apply H15 to H7 H14. prune H16.
  exists D1. search.
%%%% use the assumption formula H1 to move from the formula to an sn derivation and conclude
case H5. apply H1 to H10 H9. prune H12.
exists D. search.

%% Anything cc steps to is reducible.
Theorem c_step_reduce : ctx Gamma:c, forall T, {T : ty} =>
(forall M3 D3, {Gamma |- D3 : step cc M3} => exists D4, {Gamma |- D4 : reduce M3 T}).

intros. case H2.

Theorem reduce_of : ctx Gamma:c, forall M T D, {Gamma |- D : reduce M T} =>
  exists D1, {Gamma |- D1 : of M T}.

  intros. case H1.
  exists D1. search. exists D1. search.

Theorem of_tm : ctx Gamma:c, forall M T D, {Gamma |- D : of M T} => {Gamma |- M : tm}.
  % NOTE: searching for a signature constant works here, but not elsewhere.
  % MINOR BUG: however, searching inside the context still fails.
  intros. case H1(keep). search. search. search. search.

Theorem weaken_ctx : ctx Gamma:c, forall T, {T : ty} =>
  {Gamma |- T : ty}.

  induction on 1. intros. case H1.

  % arr case
    apply IH to H2 with (Gamma = Gamma).
    apply IH to H3 with (Gamma = Gamma).
    search.
  % top case
    % MINORBUG: why doesn't this search succeed? A constant should be able to be
    % typed in any context.
    search.
    skip.

%% CR1 & CR3
Theorem cr1_cr3 : 
(ctx G:c, forall N M,
    {G |- M : tm} =>
    (forall M' D, {G |- D : step M M'} => exists D', {G |- D' : sn N M'}) =>
        exists D, {G |- D : sn (s N) M}) =>
(ctx G2:c, forall M A B D1,
    {G2 |- D1 : of M (arr A B)} =>
    (forall X D2, {G2 |- D2 : reduce X A} => exists D3, {G2 |- D3 : reduce (app M X) B}) =>
    exists D4, {G2 |- D4 : reduce M (arr A B)}) =>
(
ctx Gamma:c, forall T, {T : ty} =>
    (forall M1 D1, {Gamma |- D1 : reduce M1 T} => exists D2 N, {Gamma |- D2 : sn N M1}) /\

    (forall M2 D50, {Gamma |- D50 : of M2 T} =>
        (forall T0 R0, (exists D1, {Gamma |- D1 : eq_tm M2 (lam T0 R0)}) => false) =>
        (forall M3 D3, {Gamma |- D3 : step M2 M3} => exists D4, {Gamma |- D4 : reduce M3 T}) =>
	exists D5, {Gamma |- D5 : reduce M2 T})
).

induction on 3. intros. split.

%%%% CR1
case H3.
%% CR1 arr case
  intros. case H6.

  % establish that we can use CR3 on cc.
  inst H11 with n = cc.
  apply c_step_reduce to H4 with (Gamma = Gamma).

  assert (forall T0 R0, (exists D1, {Gamma |- D1 : eq_tm cc (lam T0 R0)}) => false).
    intros. case H14.

  % prepare CR3 for the argument type.
  apply IH to H1 H2. apply H15 to H4 with (G6 = Gamma). case H16.

  % apply CR3
  assert exists D50, {Gamma |- D50 : of cc Z1}. exists of_cc Z1. search.
  apply H18 to H19 H14 H13 with M2 = cc.
  prune H20.

  inst H12 with n1 = D5.

  % prepare CR1 for the result type.
  apply H15 to H5 with (G6 = Gamma).
  case H22.

  % apply CR1
  apply H23 to H21 with M1 = (app M1 cc), D1 = (P cc D5).

  % apply sn_app_c
  apply sn__nat_tm to H25.
  case H26.
  apply sn_app_c to H1.
  apply H29 to H27 H25.

  exists (D1 n1 n). exists (N n n1). search.
  
%% CR1 top case
  intros. case H4.

  exists S. exists N. search.

%%%% CR3
case H3.
%% CR3 arr case
  intros.

  assert forall X D2, {Gamma |- D2 : reduce X Z1} =>
             exists D3, {Gamma |- D3 : reduce (app M2 X) Z2}.
  intros.

  % apply CR1 to show X is sn.
  assert exists N D3, {Gamma |- D3 : sn N X}.
    apply IH to H1 H2. apply H10 to H4 with (G17 = Gamma). case H11.
    apply H12 to H9.
    exists N. exists D1. search.

  % allow for induction on N.
  assert forall U N D4 D5,
      {Gamma |- N : nat} =>
      {Gamma |- D4 : reduce U Z1} =>
      {Gamma |- D5 : sn N U} =>
      exists D6, {Gamma |- D6 : reduce (app M2 U) Z2}.

    induction on 1. intros.
    % MINOR BUG: if you run this, it will think Gamma has n and n1. It doesn't, they are
    % in the context added on to Gamma. But this messes up the proof shortly due to a
    % "case not llambda".
    % case H13.

    % need to establish the prerequisites to apply CR3.

    % prereq: anything (app M2 U) steps to is reducible.
    assert forall M3 D3, {Gamma |- D3 : step (app M2 U) M3} =>
        exists D4, {Gamma |- D4 : reduce M3 Z2}.

      intros. case H14(keep).

      % step_beta case.
      assert exists D1, {Gamma |- D1 : eq_tm (lam T1 ([x]R x)) (lam T1 ([x]R x))}.
        exists refl (lam T1 ([x]R x)). search.
      apply H7 to H18. case H19.

      % step_app2 case.
      apply reduce_step to H12 H18.
      case H11(keep).
      assert exists D30, {Gamma |- D30 : sn n N'}.
        % MINOR BUG: we seem to have n:tm and n:nat running around.
        case H13.
	inst H23 with n = N'.
	inst H24 with n1 = S.
	exists P N' S. search.
      apply IH1 to H20 H19 H21.
      exists D6. search.

      % deal with sn z case.
      case H13.

      % step_app1 case.
      apply H8 to H18.
      case H19.
      inst H24 with n = U.
      inst H25 with n1 = D4.
      exists P U D4. search.

    % prereq: (app M2 U) is neutral.
    assert forall T0 R0, (exists D1, {Gamma |- D1 : eq_tm (app M2 U) (lam T0 R0)}) => false.
      intros. case H15.

    % prereq: (app M2 U) has type Z2.
    assert exists D31, {Gamma |- D31 : of (app M2 U) Z2}.
      apply reduce_of to H12.
      exists of_app M2 U Z2 Z1 D50 D1.
      apply of_tm to H6.
      apply of_tm to H16.
      apply weaken_ctx to H4 with (Gamma = Gamma).
      apply weaken_ctx to H5 with (Gamma = Gamma).
      search.

    % apply CR3
    apply IH to H1 H2.
    apply H17 to H5 with (G27 = Gamma). case H18.
    apply H20 to H16 H15 H14.
    exists D1. search.
	
    apply sn__nat_tm to H10. case H12.
    apply H11 to H13 H9 H10.
    exists D6. search.

  % finish the proof
  apply H2 to H6 H9.
  exists D4. search.

%% CR3 top case.
  intros.

  assert forall M' D, {Gamma |- D : step M2 M'} => exists N D', {Gamma |- D' : sn N M'}.
    intros.
    apply H6 to H7.
    case H8.
    exists N. exists S. search.

  abort.

%  assert exists N, forall M' D, {Gamma |- D : step M2 M'} =>
%      exists D', {Gamma |- D' : sn N M'}.
%    intros.
%
%  assert forall M' D, {Gamma |- D : step M2 M'} => exists D', {Gamma |- D' : sn 
